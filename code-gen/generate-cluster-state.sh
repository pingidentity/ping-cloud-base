#!/bin/bash

# If VERBOSE is true, then output line-by-line execution
"${VERBOSE:-false}" && set -x
"${EXIT_ON_FAILURE:-false}" && set -e

########################################################################################################################
#
# PREREQUISITES: Should be compatible with Debian.
#                This script is used by platform automation on Ubuntu (Debian) to generate K8s manifest.
#
# Note: This script must be executed within its git checkout tree after switching to the desired branch.
#
# This script may be used to generate the initial Kubernetes configurations to push into the cluster-state repository
# for a particular tenant. This repo is referred to as the cluster state repo because the EKS clusters are always
# (within a few minutes) reflective of the code in this repo. This repo is the only interface for updates to the
# clusters. In other words, kubectl commands that alter the state of the cluster are verboten outside of this repo.
#
# The intended audience of this repo is primarily the Ping Professional Services and Support team, with limited access
# granted to Customer administrators. These users may further tweak the cluster state per the tenant's requirements.
# They are expected to have an understanding of Kubernetes manifest files and kustomize, a client-side tool used to make
# further customizations to the initial state generated by this script.
#
# The script generates Kubernetes manifest files for the environments passed in by the SUPPORTED_ENVIRONMENT_TYPES
# environment variable. The manifest files for these environments contain deployments of both the Ping Cloud stack and
# the supporting tools necessary to provide an end-to-end solution.
#
# For example, the script produces a directory structure as shown below (Directories greater than a depth of 3 and
# files within the directories are omitted for brevity):
#
# ├── cluster-state
# │  └── k8s-configs
# │     ├── dev
# │     ├── prod
# │     ├── stage
# │     └── test
# │  └── profiles
# └── fluxcd
#    ├── dev
#    ├── prod
#    ├── stage
#    └── test
#
# Deploying the manifests under the fluxcd directory for a specific environment will bootstrap the cluster with a
# Continuous Delivery tool. Once the CD tool is deployed to the cluster, it will deploy the rest of the ping stack
# and supporting tools for that environment.
#
# ------------
# Requirements
# ------------
# The script requires the following tools to be installed:
#   - openssl
#   - ssh-keygen
#   - ssh-keyscan
#   - base64
#   - envsubst
#   - git
#   - rsync
#
# ------------------
# Usage instructions
# ------------------
# The script does not take any parameters, but rather acts on environment variables. The environment variables will
# be substituted into the variables in the yaml template files.
#
# The following environment variables, if present, will be used for the following purposes:
#
# ---------------------------------------------------------------------------------------------------------------------------------------------------
# Variable                         | Purpose                                            | Default (if not present)
# ---------------------------------------------------------------------------------------------------------------------------------------------------
# Variable                         | Purpose                                            | Default (if not present)
# ACCOUNT_BASE_PATH                | The account's SSM base path                        | The SSM path: /pcpt/config/k8s-config/accounts/
#                                  |                                                    |
# ACCOUNT_TYPE                     | The variable denotes the type of account based on  | No defaults
#                                  | the IS_GA flag: either 'ga' or 'non-ga'.           |                               |
#                                  |                                                    |
#                                  |                                                    |
# ARGOCD_SLACK_TOKEN_SSM_PATH      | SSM path to secret token for ArgoCD slack          | The SSM path:
#                                  | notifications                                      | ssm://pcpt/argocd/notification/slack/access_token
#                                  |                                                    |
# ARGOCD_CDE_ROLE_SSM_TEMPLATE     | SSM template path for the ArgoCD Chub -> CDE roles | The SSM template (to be rendered in python script) path:
#                                  |                                                    | '/pcpt/config/k8s-config/accounts/{env}/argo/role/arn'
#                                  |                                                    |
# ARGOCD_CDE_URL_SSM_TEMPLATE      | SSM template path for the ArgoCD Chub -> CDE URLs  | The SSM template (to be rendered in python script) path:
#                                  |                                                    | '/pcpt/config/k8s-config/accounts/{env}/cluster/url'
#                                  |                                                    |
# ARGOCD_BOOTSTRAP_ENABLED         | Feature flag to enabled/disable ArgoCD Chub -> CDE | The string "true"
#                                  | bootstrapping itself                               |
#                                  |                                                    |
# ARGOCD_ENVIRONMENTS              | All environments that Argo should manage           | The env var ${ENVIRONMENTS}
#                                  |                                                    |
# ARTIFACT_REPO_URL                | The URL for plugins (e.g. PF kits, PD extensions). | The string "unused".
#                                  | If not provided, the Ping stack will be            |
#                                  | provisioned without plugins. This URL must always  |
#                                  | have an s3 scheme, e.g.                            |
#                                  | s3://customer-repo-bucket-name.                    |
#                                  |                                                    |
# BACKUP_URL                       | The URL of the backup location. If provided, data  | The string "unused".
#                                  | backups are periodically captured and sent to this |
#                                  | URL. For AWS S3 buckets, it must be an S3 URL,     |
#                                  | e.g. s3://backups.                                 |
#                                  |                                                    |
# CLUSTER_STATE_REPO_URL           | The URL of the cluster-state repo.                 | https://github.com/pingidentity/ping-cloud-base
#                                  |                                                    |
# ENVIRONMENTS                     | The environments the customer is entitled to. This | dev test stage prod customer-hub
#                                  | will be a subset of SUPPORTED_ENVIRONMENT_TYPES    |
#                                  |                                                    |
# EXTERNAL_INGRESS_ENABLED         | List of ping apps(pingaccess pingaccess-was        | No defaults
#                                  | pingdirectory pingdelegator pingfederate) for      |
#                                  | which you can enable external ingress(the values   |
#                                  | are ping app names)                                |
#                                  | Examplelist:"pingaccess pingdirectory pingfederate |
#                                  | pingaccess-was pingdelegator"                      |
#                                  |                                                    |
# GLOBAL_TENANT_DOMAIN             | Region-independent URL used for DNS failover/      | Replaces the first segment of
#                                  | routing.                                           | the TENANT_DOMAIN value with the
#                                  |                                                    | string "global". For example, it will
#                                  |                                                    | default to "global.poc.ping.com" for
#                                  |                                                    | tenant domain "us1.poc.ping.cloud".
#                                  |                                                    |
# IRSA_ARGOCD_ANNOTATION_KEY_VALUE | The IRSA annotation to add to ArgoCD resources     | eks.amazonaws.com/role-arn: arn:aws:iam::SOME_ACCOUNT_ID:role/SOME_ROLE
#                                  |                                                    |
# IRSA_INGRESS_ANNOTATION_KEY_VALUE| The IRSA annotation to enable ingress service      | eks.amazonaws.com/role-arn: arn:aws:iam::SOME_ACCOUNT_ID:role/SOME_ROLE
#                                  | account to put ssm parameter                       |
#                                  |                                                    |
# IS_BELUGA_ENV                    | An optional flag that may be provided to indicate  | false. Only intended for Beluga
#                                  | that the cluster state is being generated for      | developers.
#                                  | testing during Beluga development. If set to true, |
#                                  | the cluster name is assumed to be the tenant name  |
#                                  | and the tenant domain assumed to be the same       |
#                                  | across all 4 CDEs. On the other hand, in PCPT, the |
#                                  | cluster name for the CDEs are hardcoded to dev,    |
#                                  | test, stage and prod. The domain names for the     |
#                                  | CDEs are derived from the TENANT_DOMAIN variable   |
#                                  | as documented above. This flag exists because the  |
#                                  | Beluga developers only have access to one domain   |
#                                  | and hosted zone in their Ping IAM account role.    |
#                                  |                                                    |
# IS_GA                            | A flag indicating whether or not this is a GA      | The SSM path: /pcpt/stage/is-ga
#                                  | customer.                                          |
#                                  |                                                    |
# IS_MULTI_CLUSTER                 | Flag indicating whether or not this is a           | false
#                                  | multi-cluster deployment.                          |
#                                  |                                                    |
# IS_MY_PING                       | A flag indicating whether or not this is a MyPing  | The SSM path: /pcpt/customer/sso/is-myping
#                                  | customer.                                          |
#                                  |                                                    |
# K8S_GIT_BRANCH                   | The Git branch within the above Git URL.           | The git branch where this script
#                                  |                                                    | exists, i.e. CI_COMMIT_REF_NAME
#                                  |                                                    |
# K8S_GIT_URL                      | The Git URL of the Kubernetes base manifest files. | https://github.com/pingidentity/ping-cloud-base
#                                  |                                                    |
# KARPENTER_INSTANCE_PROFILE       | Karpenter Instance profile attached to EKS Clsuter | KarpenterInstanceProfile
#                                  | IAM Node role                                      |
#                                  |                                                    |
# LOG_ARCHIVE_URL                  | The URL of the log archives. If provided, logs are | The string "unused".
#                                  | periodically captured and sent to this URL. For    |
#                                  | AWS S3 buckets, it must be an S3 URL, e.g.         |
#                                  | s3://logs.                                         |
#                                  |                                                    |
# PD_MONITOR_BUCKET_URL            | The URL of the monitor,ldif exports and csd-log    |
#                                  | archives.If provided, logs are periodically        | The string "unused"
#                                  | captured and sent to this URL. Used only for       |
#                                  | PingDirectory at the moment                        |
#                                  |                                                    |
# MYSQL_PASSWORD                   | The DBA password of the PingCentral MySQL RDS      | The SSM path:
#                                  | database.                                          | ssm://aws/reference/secretsmanager//pcpt/ping-central/dbserver#password
#                                  |                                                    |
# MYSQL_SERVICE_HOST               | The hostname of the MySQL database server.         | pingcentraldb.${PRIMARY_TENANT_DOMAIN}
#                                  |                                                    |
# MYSQL_USER                       | The DBA user of the PingCentral MySQL RDS          | The SSM path:
#                                  | database.                                          | ssm://aws/reference/secretsmanager//pcpt/ping-central/dbserver#username
#                                  |                                                    |
# NEW_RELIC_LICENSE_KEY            | The key of NewRelic APM Agent used to send data to | The SSM path: ssm://pcpt/sre/new-relic/java-agent-license-key
#                                  | NewRelic account.                                  |
#                                  |                                                    |
# NOTIFICATION_ENABLED             | Flag indicating if alerts should be sent to the    | True
#                                  | endpoint configured in the argo-events             |
#                                  |                                                    |
# NLB_EIP_PATH_PREFIX              | The SSM path prefix which stores comma separated   | The string "unused".
#                                  | AWS Elastic IP allocation IDs that exist in the    |
#                                  | CDE account of the Ping Cloud customers.           |
#                                  | The environment type is appended to the SSM key    |
#                                  | path before the value is retrieved from the        |
#                                  | AWS SSM endpoint. The EIP allocation IDs must be   |
#                                  | added as an annotation to the corresponding K8s    |
#                                  | service for the AWS NLB to use the AWS Elastic IP. |
#                                  |                                                    |
# CUSTOMER_SSM_PATH_PREFIX         | The prefix of an SSM path that contains PingOne    | /pcpt/customer
#                                  | state data required for the P14C/P1AS integration. |
#                                  |                                                    |
# CUSTOMER_SSO_SSM_PATH_PREFIX     | The prefix of an SSM path that contains PingOne    | ${CUSTOMER_SSM_PATH_PREFIX}/sso
#                                  | state data required for the P14C/P1AS integration. |
#                                  |                                                    |
# PF_PROVISIONING_ENABLED          | Feature Flag - Indicates if the outbound           | False
#                                  | provisioning feature for PingFederate is enabled   |
#                                  | !! Not yet available for multi-region customers !! |
#                                  |                                                    |
# PGO_BUCKET_URI_SUFFIX            | The SSM path suffix to the pgo backups bucket uri  | The SSM path: /pgo-bucket/uri
#                                  |                                                    |
# PING_ARTIFACT_REPO_URL           | This environment variable can be used to overwrite | https://ping-artifacts.s3-us-west-2.amazonaws.com
#                                  | the default endpoint for public plugins. This URL  |
#                                  | must use an https scheme as shown by the default   |
#                                  | value.                                             |
#                                  |                                                    |
# PING_IDENTITY_DEVOPS_KEY         | The key to the devops user.                        | The SSM path:
#                                  |                                                    | ssm://pcpt/devops-license/key
#                                  |                                                    |
# PING_IDENTITY_DEVOPS_USER        | A user with license to run Ping Software.          | The SSM path:
#                                  |                                                    | ssm://pcpt/devops-license/user
#                                  |                                                    |
# PLATFORM_EVENT_QUEUE_NAME        | The name of the queue that may be used to notify   | v2_platform_event_queue.fifo
#                                  | PingCloud applications of platform events. This    |
#                                  | is currently only used if the orchestrator for     |
#                                  | PingCloud environments is MyPing.                  |
#                                  |                                                    |
# PRIMARY_REGION                   | In multi-cluster environments, the primary region. | Same as REGION.
#                                  | Only used if IS_MULTI_CLUSTER is true.             |
#                                  |                                                    |
# PRIMARY_TENANT_DOMAIN            | In multi-cluster environments, the primary domain. | Same as TENANT_DOMAIN.
#                                  | Only used if IS_MULTI_CLUSTER is true.             |
#                                  |                                                    |
# PROM_NOTIFICATION_ENABLED        | Flag indicating if PGO alerts should be sent to    | False
#                                  | the endpoint configured in the argo-events         |
#                                  |                                                    |
# PROM_SLACK_CHANNEL               | The Slack channel name for PGO argo-events to send | CDE environment: p1as-application-oncall
#                                  | notification.                                      |
#                                  |                                                    |
# RADIUS_PROXY_ENABLED             | Feature Flag - Indicates if the radius proxy       | False
#                                  | feature for PingFederate engines is enabled        |
#                                  |                                                    |
# REGION                           | The region where the tenant environment is         | us-west-2
#                                  | deployed. For PCPT, this is a required parameter   |
#                                  | to Container Insights, an AWS-specific logging     |
#                                  | and monitoring solution.                           |
#                                  |                                                    |
# REGION_NICK_NAME                 | An optional nick name for the region. For example, | Same as REGION.
#                                  | this variable may be set to a unique name in       |
#                                  | multi-cluster deployments which live in the same   |
#                                  | region. The nick name will be used as the name of  |
#                                  | the region-specific code directory in the cluster  |
#                                  | state repo.                                        |
#                                  |                                                    |
# SECONDARY_TENANT_DOMAINS         | A comma-separated list of tenant domain suffixes   | No default.
#                                  | of secondary regions in multi-region environments, |
#                                  | e.g. "xxx.eu1.ping.cloud,xxx.au1.ping.cloud".      |
#                                  | The primary tenant domain suffix must not be in    |
#                                  | the list. Only used if IS_MULTI_CLUSTER is true.   |
#                                  |                                                    |
# SERVER_PROFILE_URL               | The URL for the server-profiles repo.              | URL of CLUSTER_STATE_REPO_URL with the
#                                  |                                                    | name profile-repo, if not provided.
#                                  |                                                    |
# SERVICE_SSM_PATH_PREFIX          | The prefix of the SSM path that contains service   | /pcpt/service
#                                  | state data required for the cluster.               |
#                                  |                                                    |
# SLACK_CHANNEL                    | The Slack channel name for argo-events to send     | CDE environment: p1as-application-oncall
#                                  | notification.                                      |
#                                  |                                                    |
# NON_GA_SLACK_CHANNEL             | The Slack channel name for argo-events to send     | CDE environment: nowhere
#                                  | notification in case of IS_GA set to 'false' to    | Dev environment: nowhere
#                                  | reduce amount of unnecessary notifications sent    |
#                                  | to on-call channel. Overrides SLACK_CHANNEL        |
#                                  | variable value if IS_GA=false. By default, set     |
#                                  | to non-existent channel name to prevent flooding.  |
#                                  |                                                    |
# SIZE                             | Size of the environment, which pertains to the     | x-small
#                                  | number of user identities. Legal values are        |
#                                  | x-small, small, medium or large.                   |
#                                  |                                                    |
# SSH_ID_KEY_FILE                  | The file containing the private-key (in PEM        | No default
#                                  | format) used by the CD tool and Ping containers to |
#                                  | access the cluster state and config repos,         |
#                                  | respectively. If not provided, a new key-pair      |
#                                  | will be generated by the script. If provided, the  |
#                                  | SSH_ID_PUB_FILE must also be provided and          |
#                                  | correspond to this private key.                    |
#                                  |                                                    |
# SSH_ID_PUB_FILE                  | The file containing the public-key (in PEM format) | No default
#                                  | used by the CD tool and Ping containers to access  |
#                                  | the cluster state and config repos, respectively.  |
#                                  | If not provided, a new key-pair will be generated  |
#                                  | by the script. If provided, the SSH_ID_KEY_FILE    |
#                                  | must also be provided and correspond to this       |
#                                  | public key.                                        |
#                                  |                                                    |
# SUPPORTED_ENVIRONMENT_TYPES      | The environment types that will be supported for   | dev test stage prod customer-hub
#                                  | the customer                                       |
#                                  |                                                    |
# TARGET_DIR                       | The directory where the manifest files will be     | /tmp/sandbox
#                                  | generated. If the target directory exists, it will |
#                                  | be deleted.                                        |
#                                  |                                                    |
# TENANT_DOMAIN                    | The tenant's domain suffix that's common to all    | ci-cd.ping-oasis.com
#                                  | CDEs e.g. k8s-icecream.com. The tenant domain in   |
#                                  | each CDE is assumed to have the CDE name as the    |
#                                  | prefix, followed by a hyphen. For example, for the |
#                                  | above suffix, the tenant domain for stage is       |
#                                  | assumed to be stage-k8s-icecream.com and a hosted  |
#                                  | zone assumed to exist on Route53 for that domain.  |
#                                  |                                                    |
# TENANT_NAME                      | The name of the tenant, e.g. k8s-icecream. If      | First segment of the TENANT_DOMAIN
#                                  | provided, this value will be used for the cluster  | value. E.g. it will default to "ci-cd"
#                                  | name and must have the correct case (e.g. ci-cd    | for tenant domain "ci-cd.ping-oasis.com"
#                                  | vs. CI-CD).                                        |
#                                  |                                                    |
#                                  |                                                    |
# UPGRADE                          | Indicates generate-cluster-state.sh is running as  | The string "false"
#                                  | an upgrade not an initial generation               |
#                                  |                                                    |
######################################################################################################################################################

#### SCRIPT START ####

# Ensure that this script works from any working directory.
SCRIPT_HOME=$(cd $(dirname ${0}) 2>/dev/null; pwd)
pushd "${SCRIPT_HOME}" >/dev/null 2>&1

# Quiet mode where instructional messages are omitted.
QUIET="${QUIET:-false}"

# Source some utility methods.
. ../utils.sh

# Source aws specific utility methods.
. ./aws/utils.sh

########################################################################################################################
# Substitute variables in all template files in the provided directory.
#
# Arguments
#   ${1} -> The directory that contains the template files.
########################################################################################################################

# The list of variables in the template files that will be substituted by default.
# Note: DEFAULT_VARS is a superset of ENV_VARS_TO_SUBST within upgrade-cluster-state.sh. These variables should be kept
# in sync with the following exceptions: LAST_UPDATE_REASON and NEW_RELIC_LICENSE_KEY_BASE64 should only be found
# within DEFAULT_VARS
# Note: only secret variables are substituted into YAML files. Environments variables are just written to an env_vars
# file and substituted at runtime by the continuous delivery tool running in cluster.
# shellcheck disable=SC2016
DEFAULT_VARS='${LAST_UPDATE_REASON}
${PING_IDENTITY_DEVOPS_USER}
${PING_IDENTITY_DEVOPS_KEY}
${NEW_RELIC_LICENSE_KEY_BASE64}
${TENANT_NAME}
${SSH_ID_KEY_BASE64}
${IS_MULTI_CLUSTER}
${PLATFORM_EVENT_QUEUE_NAME}
${CUSTOMER_SSM_PATH_PREFIX}
${CUSTOMER_SSO_SSM_PATH_PREFIX}
${SERVICE_SSM_PATH_PREFIX}
${REGION}
${REGION_NICK_NAME}
${PRIMARY_REGION}
${TENANT_DOMAIN}
${PRIMARY_TENANT_DOMAIN}
${PRIMARY_TENANT_DOMAIN_DERIVED}
${SECONDARY_TENANT_DOMAINS}
${GLOBAL_TENANT_DOMAIN}
${ARTIFACT_REPO_URL}
${PING_ARTIFACT_REPO_URL}
${PD_MONITOR_BUCKET_URL}
${LOG_ARCHIVE_URL}
${BACKUP_URL}
${PGO_BACKUP_BUCKET_NAME}
${PING_CLOUD_NAMESPACE}
${K8S_GIT_URL}
${K8S_GIT_BRANCH}
${ECR_REGISTRY_NAME}
${KNOWN_HOSTS_CLUSTER_STATE_REPO}
${CLUSTER_STATE_REPO_URL}
${CLUSTER_STATE_REPO_BRANCH}
${CLUSTER_STATE_REPO_PATH_DERIVED}
${SERVER_PROFILE_URL}
${SERVER_PROFILE_BRANCH_DERIVED}
${SERVER_PROFILE_PATH}
${ENV}
${ENVIRONMENT_TYPE}
${KUSTOMIZE_BASE}
${ACCOUNT_TYPE}
${LETS_ENCRYPT_SERVER}
${USER_BASE_DN}
${USER_BASE_DN_2}
${USER_BASE_DN_3}
${USER_BASE_DN_4}
${USER_BASE_DN_5}
${ADMIN_CONSOLE_BRANDING}
${ENVIRONMENT_PREFIX}
${NEW_RELIC_ENVIRONMENT_NAME}
${PF_PD_BIND_PORT}
${PF_PD_BIND_PROTOCOL}
${PF_PD_BIND_USESSL}
${PF_MIN_HEAP}
${PF_MAX_HEAP}
${PF_MIN_YGEN}
${PF_MAX_YGEN}
${PA_WAS_MIN_HEAP}
${PA_WAS_MAX_HEAP}
${PA_WAS_MIN_YGEN}
${PA_WAS_MAX_YGEN}
${PA_WAS_GCOPTION}
${PA_MIN_HEAP}
${PA_MAX_HEAP}
${PA_MIN_YGEN}
${PA_MAX_YGEN}
${PA_GCOPTION}
${MYSQL_SERVICE_HOST}
${MYSQL_USER}
${MYSQL_PASSWORD}
${MYSQL_DATABASE}
${CLUSTER_NAME}
${CLUSTER_NAME_LC}
${CLUSTER_ENDPOINT}
${KARPENTER_INSTANCE_PROFILE}
${DNS_ZONE}
${VALUES_FILES_DNS_ZONE}
${DNS_ZONE_DERIVED}
${PRIMARY_DNS_ZONE}
${PRIMARY_DNS_ZONE_DERIVED}
${METADATA_IMAGE_TAG}
${BOOTSTRAP_IMAGE_TAG}
${P14C_INTEGRATION_IMAGE_TAG}
${ANSIBLE_BELUGA_IMAGE_TAG}
${PINGCENTRAL_IMAGE_TAG}
${PINGACCESS_IMAGE_TAG}
${PINGACCESS_WAS_IMAGE_TAG}
${PINGFEDERATE_IMAGE_TAG}
${PINGDIRECTORY_IMAGE_TAG}
${PINGDELEGATOR_IMAGE_TAG}
${IRSA_PING_ANNOTATION_KEY_VALUE}
${IRSA_PA_ANNOTATION_KEY_VALUE}
${IRSA_PD_ANNOTATION_KEY_VALUE}
${IRSA_PF_ANNOTATION_KEY_VALUE}
${IRSA_ARGOCD_ANNOTATION_KEY_VALUE}
${IRSA_INGRESS_ANNOTATION_KEY_VALUE}
${IRSA_CWAGENT_ANNOTATION_KEY_VALUE}
${KARPENTER_ROLE_ANNOTATION_KEY_VALUE}
${NLB_NGX_PUBLIC_ANNOTATION_KEY_VALUE}
${NOTIFICATION_ENABLED}
${NOTIFICATION_ENDPOINT}
${PF_PROVISIONING_ENABLED}
${RADIUS_PROXY_ENABLED}
${EXTERNAL_INGRESS_ENABLED}
${IMAGE_TAG_PREFIX}
${ARGOCD_BOOTSTRAP_ENABLED}
${ARGOCD_CDE_ROLE_SSM_TEMPLATE}
${ARGOCD_CDE_URL_SSM_TEMPLATE}
${ARGOCD_ENVIRONMENTS}
${ARGOCD_SLACK_TOKEN_BASE64}
${SLACK_CHANNEL}
${PROM_SLACK_CHANNEL}
${DASH_REPO_URL}
${DASH_REPO_BRANCH}
${APP_RESYNC_SECONDS}
${IMAGE_LIST}'

# Variables to replace within the generated cluster state code
REPO_VARS="${REPO_VARS:-${DEFAULT_VARS}}"

# Variables to replace in the generated bootstrap code
BOOTSTRAP_VARS='${APP_RESYNC_SECONDS}
${ARGOCD_BOOTSTRAP_ENABLED}
${ARGOCD_CDE_ROLE_SSM_TEMPLATE}
${ARGOCD_CDE_URL_SSM_TEMPLATE}
${ARGOCD_ENVIRONMENTS}
${CLUSTER_ENDPOINT}
${KARPENTER_INSTANCE_PROFILE}
${CLUSTER_STATE_REPO_BRANCH}
${CLUSTER_STATE_REPO_URL}
${CUSTOMER_SSO_SSM_PATH_PREFIX}
${IRSA_ARGOCD_ANNOTATION_KEY_VALUE}
${KARPENTER_ROLE_ANNOTATION_KEY_VALUE}
${K8S_GIT_BRANCH}
${K8S_GIT_URL}
${KNOWN_HOSTS_CLUSTER_STATE_REPO}
${PGO_BACKUP_BUCKET_NAME}
${PING_CLOUD_NAMESPACE}
${REGION_NICK_NAME}
${REGION}
${SLACK_CHANNEL}
${SSH_ID_KEY_BASE64}
${TENANT_DOMAIN}
${TENANT_NAME}'


########################################################################################################################
# Export some derived environment variables.
########################################################################################################################
add_derived_variables() {
  # The directory within the cluster state repo for the region's manifest files.
  export CLUSTER_STATE_REPO_PATH_DERIVED="\${REGION_NICK_NAME}"

  # Server profile branch. The directory is in each app's env_vars file.
  export SERVER_PROFILE_BRANCH_DERIVED="\${CLUSTER_STATE_REPO_BRANCH}"

  # Zone for this region and the primary region.
  export DNS_ZONE_DERIVED="\${DNS_ZONE}"
  export PRIMARY_DNS_ZONE_DERIVED="\${PRIMARY_DNS_ZONE}"

  # Zone for this region and the primary region.
  # Note: VALUES_FILES_DNS_ZONE is a hack around the issue of ${REGION_ENV} not substituting for values.yaml files
  # That variable is only substituted by git-ops-command.sh which values.yaml file do not use. This should be cleaned
  # up with PDO-5769
  if "${IS_BELUGA_ENV}" || test "${ENV}" = "${CUSTOMER_HUB}"; then
    export DNS_ZONE="\${TENANT_DOMAIN}"
    export VALUES_FILES_DNS_ZONE="\${TENANT_DOMAIN}"
    export PRIMARY_DNS_ZONE="\${PRIMARY_TENANT_DOMAIN}"
  else
    export DNS_ZONE="\${REGION_ENV}-\${TENANT_DOMAIN}"
    export VALUES_FILES_DNS_ZONE="\${ENV}-\${TENANT_DOMAIN}"
    export PRIMARY_DNS_ZONE="\${ENV}-\${PRIMARY_TENANT_DOMAIN}"
  fi

  export PRIMARY_TENANT_DOMAIN_DERIVED="\${PRIMARY_TENANT_DOMAIN}"

  # This variable's value will make it onto the branding for all admin consoles and
  # will include the name of the environment and the region where it's deployed.
  export ADMIN_CONSOLE_BRANDING="\${ENV}-\${REGION}"

  # This variable's value will be used as the prefix to distinguish between worker apps for different CDEs for a
  # single P14C tenant. All of these apps will be created within the "Administrators" environment in the tenant.
  export ENVIRONMENT_PREFIX="\${TENANT_NAME}-\${REGION_ENV}-\${REGION_NICK_NAME}"

  # The name of the environment as it will appear on the NewRelic console.
  export NEW_RELIC_ENVIRONMENT_NAME="\${TENANT_NAME}_\${REGION_ENV}_\${REGION_NICK_NAME}_k8s-cluster"
}

########################################################################################################################
# Export the IS_GA environment variable for the provided customer. If it's already present as a boolean environment
# variable, then export it as is. Otherwise, if the SSM path prefix for it is not 'unused', then try to retrieve it out
# of SSM. On error, print a warning message, but default the value to false. On success, use the value from SSM, if it
# is a valid boolean. Otherwise, default it to false.
#
# Arguments
#   ${1} -> The value of the IS_GA flag.
########################################################################################################################
get_is_ga_variable() {
  if test "${IS_GA}" = 'true' || test "${IS_GA}" = 'false'; then
    export IS_GA="${IS_GA}"
    return
  fi

  local ssm_path_prefix="$1"

  # Default false
  IS_GA='false'

  if [ "${ssm_path_prefix}" != "unused" ]; then
    # Getting value from ssm parameter store.
    if ! ssm_value=$(get_ssm_value "${ssm_path_prefix}"); then
      echo "Warn: ${ssm_value}"
      echo "Defaulting IS_GA=false."
    else
      IS_GA="${ssm_value}"
    fi
  fi

  if test "${IS_GA}" = 'true' || test "${IS_GA}" = 'false'; then
    export IS_GA="${IS_GA}"
  else
    export IS_GA='false'
  fi
}

########################################################################################################################
# Export the IS_MY_PING environment variable for the provided customer. If it's already present as a boolean environment
# variable, then export it as is. Otherwise, if the SSM path prefix for it is not 'unused', then try to retrieve it out
# of SSM. On error, print a warning message, but default the value to false. On success, use the value from SSM.
# Otherwise, default it to false.
#
# Arguments
#   ${1} -> The value of the IS_MY_PING flag.
########################################################################################################################
get_is_myping_variable() {
  if test "${IS_MY_PING}" = 'true' || test "${IS_MY_PING}" = 'false'; then
    export IS_MY_PING="${IS_MY_PING}"
    return
  fi

  local ssm_path_prefix="$1"

  # Default false
  IS_MY_PING='false'

  if [ "${ssm_path_prefix}" != "unused" ]; then
    # Getting value from ssm parameter store.
    if ! ssm_value=$(get_ssm_value "${ssm_path_prefix}"); then
      echo "Warn: ${ssm_value}"
      echo "Defaulting IS_MY_PING=false."
    else
      IS_MY_PING="${ssm_value}"
    fi
  fi

  if test "${IS_MY_PING}" = 'true' || test "${IS_MY_PING}" = 'false'; then
    export IS_MY_PING="${IS_MY_PING}"
  else
    export IS_MY_PING='false'
  fi
}

# Support the various ways to actually set the SSH key pair env vars
set_ssh_key_pair() {
  # Autogenerate if no keys provided
  if test -z "${SSH_ID_PUB_FILE}" && test -z "${SSH_ID_KEY_FILE}"; then
    echo 'Generating key-pair for SSH access'
    generate_ssh_key_pair

  # Upgrade flow - we only get a private key from upgrade-cluster-state.sh
  elif test -z "${SSH_ID_PUB_FILE}" && test -f "${SSH_ID_KEY_FILE}"; then
    echo 'This is an upgrade - using provided private key for SSH access. No public key available'
    export SSH_ID_KEY_BASE64=$(base64_no_newlines "${SSH_ID_KEY_FILE}")

  # Both public file and key file provided
  elif test -f "${SSH_ID_PUB_FILE}" && test -f "${SSH_ID_KEY_FILE}"; then
    echo 'Using provided key-pair for SSH access'
    export SSH_ID_PUB=$(cat "${SSH_ID_PUB_FILE}")
    export SSH_ID_KEY_BASE64=$(base64_no_newlines "${SSH_ID_KEY_FILE}")

  # Unsupported flow - no private key provided at all or not a file
  else
    echo 'Provide SSH key-pair files via SSH_ID_PUB_FILE/SSH_ID_KEY_FILE env vars, or omit both for key-pair to be generated'
    exit 1
  fi
}

# Organizes the files from code-gen directory to a tmp directory for push-cluster-state script
organize_code_for_csr() {
  # find all the apps under code-gen/templates directory
  local app_paths=$(find "${TEMPLATES_HOME}" -maxdepth 1 -mindepth 1 -type d ! -path '*/cde' ! -path '*/common' ! -path '*/customer-hub' ! -path '*/fluxcd')

  for app_path in ${app_paths}; do
    local app_name=$(basename "${app_path}")

    # source the config or continue to next app if config not there
    source "${app_path}/config.sh" || continue

    echo ---
    echo "For app '${app_name}':"
    echo "Using CDE_DEPLOY: ${CDE_DEPLOY}"
    echo "Using CHUB_DEPLOY:  ${CHUB_DEPLOY}"
    echo

    # Add the app directory to the tmp directory if the deploy env var aligns with the env env var
    if (test "${ENV}" = "${CUSTOMER_HUB}" && ${CHUB_DEPLOY}) || (test "${ENV}" != "${CUSTOMER_HUB}" && ${CDE_DEPLOY}); then
      local app_target_dir=${ENV_DIR}/${app_name}
      mkdir -p "${app_target_dir}"

      cd "${app_path}"
      rsync -rR * --exclude config.sh "${app_target_dir}"
      cd - >/dev/null 2>&1

      # Rename to the actual region nick name.
      mv "${app_target_dir}/region" "${app_target_dir}/${REGION_NICK_NAME}"

      # Handle prod vs. non-prod values files
      case "${ENV}" in
        dev | test)
          # delete all prod-values.yaml files
          find "${app_target_dir}" -type f -name "prod-values.yaml" -exec rm -f {} +
          ;;
        stage | prod | customer-hub)
          # rename prod-values.yaml to values.yaml (overwriting values.yaml if it exists)
          prod_values_files=$(find "${app_target_dir}" -type f -name "prod-values.yaml")
          for prod_values_file in ${prod_values_files}; do
            mv -f "${prod_values_file}" "${prod_values_file//prod-/}"
          done
          ;;
      esac

      # Substitute the env vars in the app directories
      substitute_vars "${app_target_dir}" "${REPO_VARS}"
      # TODO: These duplicate calls are needed to substitute the derived variables & the IS_BELUGA_ENV
      #  clean this up with PDO-5769 when all apps are migrated to values files by adding IS_BELUGA_ENV to DEFAULT_VARS
      #  and redoing how derived variables are set
      substitute_vars "${app_target_dir}" "${REPO_VARS}"
    fi
  done
}

# Checking required tools and environment variables.
check_binaries "openssl" "ssh-keygen" "ssh-keyscan" "base64" "envsubst" "git" "aws" "rsync"
HAS_REQUIRED_TOOLS=${?}

if test ${HAS_REQUIRED_TOOLS} -ne 0; then
  # Go back to previous working directory, if different, before exiting.
  popd >/dev/null 2>&1
  exit 1
fi

if test -z "${IS_MULTI_CLUSTER}"; then
  IS_MULTI_CLUSTER=false
fi


########################################################################################################################
# Print out the initial values provided for each variable.
########################################################################################################################
echo "Initial TENANT_NAME: ${TENANT_NAME}"
echo "Initial SIZE: ${SIZE}"

echo "Initial SUPPORTED_ENVIRONMENT_TYPES: ${SUPPORTED_ENVIRONMENT_TYPES}"
echo "Initial ENVIRONMENTS: ${ENVIRONMENTS}"
echo "Initial IS_MULTI_CLUSTER: ${IS_MULTI_CLUSTER}"
echo "Initial PLATFORM_EVENT_QUEUE_NAME: ${PLATFORM_EVENT_QUEUE_NAME}"
echo "Initial CUSTOMER_SSM_PATH_PREFIX: ${CUSTOMER_SSM_PATH_PREFIX}"
echo "Initial CUSTOMER_SSO_SSM_PATH_PREFIX: ${CUSTOMER_SSO_SSM_PATH_PREFIX}"
echo "Initial SERVICE_SSM_PATH_PREFIX: ${SERVICE_SSM_PATH_PREFIX}"
echo "Initial REGION: ${REGION}"
echo "Initial REGION_NICK_NAME: ${REGION_NICK_NAME}"
echo "Initial PRIMARY_REGION: ${PRIMARY_REGION}"
echo "Initial TENANT_DOMAIN: ${TENANT_DOMAIN}"
echo "Initial GLOBAL_TENANT_DOMAIN: ${GLOBAL_TENANT_DOMAIN}"
echo "Initial PRIMARY_TENANT_DOMAIN: ${PRIMARY_TENANT_DOMAIN}"
echo "Initial SECONDARY_TENANT_DOMAINS: ${SECONDARY_TENANT_DOMAINS}"

echo "Initial CLUSTER_STATE_REPO_URL: ${CLUSTER_STATE_REPO_URL}"
echo "Initial SERVER_PROFILE_URL: ${SERVER_PROFILE_URL}"

echo "Initial ARTIFACT_REPO_URL: ${ARTIFACT_REPO_URL}"
echo "Initial PING_ARTIFACT_REPO_URL: ${PING_ARTIFACT_REPO_URL}"

echo "Initial PD_MONITOR_BUCKET_URL: ${PD_MONITOR_BUCKET_URL}"
echo "Initial LOG_ARCHIVE_URL: ${LOG_ARCHIVE_URL}"
echo "Initial BACKUP_URL: ${BACKUP_URL}"

echo "Initial MYSQL_SERVICE_HOST: ${MYSQL_SERVICE_HOST}"
echo "Initial MYSQL_USER: ${MYSQL_USER}"
echo "Initial MYSQL_PASSWORD: ${MYSQL_PASSWORD}"
echo "Initial MYSQL_DATABASE: ${MYSQL_DATABASE}"


echo "Initial PING_IDENTITY_DEVOPS_USER: ${PING_IDENTITY_DEVOPS_USER}"

echo "Initial K8S_GIT_URL: ${K8S_GIT_URL}"
echo "Initial K8S_GIT_BRANCH: ${K8S_GIT_BRANCH}"

echo "Initial SSH_ID_PUB_FILE: ${SSH_ID_PUB_FILE}"
echo "Initial SSH_ID_KEY_FILE: ${SSH_ID_KEY_FILE}"

echo "Initial PF_PROVISIONING_ENABLED: ${PF_PROVISIONING_ENABLED}"
echo "Initial PGO_BACKUP_BUCKET_NAME: ${PGO_BACKUP_BUCKET_NAME}"

echo "Initial RADIUS_PROXY_ENABLED: ${RADIUS_PROXY_ENABLED}"
echo "Initial EXTERNAL_INGRESS_ENABLED: ${EXTERNAL_INGRESS_ENABLED}"

echo "Initial ARGOCD_BOOTSTRAP_ENABLED: ${ARGOCD_BOOTSTRAP_ENABLED}"
echo "Initial ARGOCD_CDE_ROLE_SSM_TEMPLATE: ${ARGOCD_CDE_ROLE_SSM_TEMPLATE}"
echo "Initial ARGOCD_CDE_URL_SSM_TEMPLATE: ${ARGOCD_CDE_URL_SSM_TEMPLATE}"
echo "Initial ARGOCD_ENVIRONMENTS: ${ARGOCD_ENVIRONMENTS}"

echo "Initial TARGET_DIR: ${TARGET_DIR}"
echo "Initial IS_BELUGA_ENV: ${IS_BELUGA_ENV}"

echo "Initial ACCOUNT_BASE_PATH: ${ACCOUNT_BASE_PATH}"
echo "Initial PGO_BUCKET_URI_SUFFIX: ${PGO_BUCKET_URI_SUFFIX}"

echo "Initial IRSA_PING_ANNOTATION_KEY_VALUE: ${IRSA_PING_ANNOTATION_KEY_VALUE}"
echo "Initial IRSA_PA_ANNOTATION_KEY_VALUE: ${IRSA_PA_ANNOTATION_KEY_VALUE}"
echo "Initial IRSA_PD_ANNOTATION_KEY_VALUE: ${IRSA_PD_ANNOTATION_KEY_VALUE}"
echo "Initial IRSA_PF_ANNOTATION_KEY_VALUE: ${IRSA_PF_ANNOTATION_KEY_VALUE}"
echo "Initial IRSA_ARGOCD_ANNOTATION_KEY_VALUE: ${IRSA_ARGOCD_ANNOTATION_KEY_VALUE}"
echo "Initial IRSA_CWAGENT_ANNOTATION_KEY_VALUE: ${IRSA_CWAGENT_ANNOTATION_KEY_VALUE}"
echo "Initial IRSA_INGRESS_ANNOTATION_KEY_VALUE: ${IRSA_INGRESS_ANNOTATION_KEY_VALUE}"
echo "Initial KARPENTER_ROLE_ANNOTATION_KEY_VALUE: ${KARPENTER_ROLE_ANNOTATION_KEY_VALUE}"
echo "Initial NLB_NGX_PUBLIC_ANNOTATION_KEY_VALUE: ${NLB_NGX_PUBLIC_ANNOTATION_KEY_VALUE}"

echo "Initial CLUSTER_ENDPOINT: ${CLUSTER_ENDPOINT}"
echo "Initial KARPENTER_INSTANCE_PROFILE: ${KARPENTER_INSTANCE_PROFILE}"

echo "Initial SLACK_CHANNEL: ${SLACK_CHANNEL}"
echo "Initial NON_GA_SLACK_CHANNEL: ${NON_GA_SLACK_CHANNEL}"
echo "Initial PROM_SLACK_CHANNEL: ${PROM_SLACK_CHANNEL}"

echo "Initial IMAGE_LIST: ${IMAGE_LIST}"
echo "Initial IMAGE_TAG_PREFIX: ${IMAGE_TAG_PREFIX}"

echo "Initial APP_RESYNC_SECONDS: ${APP_RESYNC_SECONDS}"

echo "Initial DASHBOARD_REPO_URL: ${DASHBOARD_REPO_URL}"

echo ---


########################################################################################################################
# Set the values for each variable.
########################################################################################################################

# Use defaults for other variables, if not present.
export IS_BELUGA_ENV="${IS_BELUGA_ENV:-false}"

TENANT_DOMAIN="${TENANT_DOMAIN:-ci-cd.ping-oasis.com}"
export TENANT_NAME="${TENANT_NAME:-${TENANT_DOMAIN%%.*}}"
export SIZE="${SIZE:-x-small}"

### Region-specific environment variables ###
export REGION="${REGION:-us-west-2}"
export REGION_NICK_NAME="${REGION_NICK_NAME:-${REGION}}"

TENANT_DOMAIN_NO_DOT_SUFFIX="${TENANT_DOMAIN%.}"
export TENANT_DOMAIN="${TENANT_DOMAIN_NO_DOT_SUFFIX}"

export ARTIFACT_REPO_URL="${ARTIFACT_REPO_URL:-unused}"

export PLATFORM_EVENT_QUEUE_NAME=${PLATFORM_EVENT_QUEUE_NAME:-v2_platform_event_queue.fifo}
export CUSTOMER_SSM_PATH_PREFIX=${CUSTOMER_SSM_PATH_PREFIX:-/pcpt/customer}
export CUSTOMER_SSO_SSM_PATH_PREFIX=${CUSTOMER_SSO_SSM_PATH_PREFIX:-${CUSTOMER_SSM_PATH_PREFIX}/sso}
export SERVICE_SSM_PATH_PREFIX=${SERVICE_SSM_PATH_PREFIX:-/pcpt/service}

export LAST_UPDATE_REASON="${LAST_UPDATE_REASON:-NA}"

### Base environment variables ###
export IS_MULTI_CLUSTER="${IS_MULTI_CLUSTER}"

export PRIMARY_REGION="${PRIMARY_REGION:-${REGION}}"
PRIMARY_TENANT_DOMAIN_NO_DOT_SUFFIX="${PRIMARY_TENANT_DOMAIN%.}"
export PRIMARY_TENANT_DOMAIN="${PRIMARY_TENANT_DOMAIN_NO_DOT_SUFFIX:-${TENANT_DOMAIN_NO_DOT_SUFFIX}}"
export SECONDARY_TENANT_DOMAINS="${SECONDARY_TENANT_DOMAINS}"

if "${IS_BELUGA_ENV}"; then
  DERIVED_GLOBAL_TENANT_DOMAIN="global.${TENANT_DOMAIN_NO_DOT_SUFFIX}"
  # 'yq' is only checked here because it is only used within Developer CDEs
  check_binaries "yq" || { popd >/dev/null 2>&1 && exit 1; }
else
  DERIVED_GLOBAL_TENANT_DOMAIN="$(echo "${TENANT_DOMAIN_NO_DOT_SUFFIX}" | sed -e "s/\([^.]*\).[^.]*.\(.*\)/global.\1.\2/")"
fi
GLOBAL_TENANT_DOMAIN_NO_DOT_SUFFIX="${GLOBAL_TENANT_DOMAIN%.}"
export GLOBAL_TENANT_DOMAIN="${GLOBAL_TENANT_DOMAIN_NO_DOT_SUFFIX:-${DERIVED_GLOBAL_TENANT_DOMAIN}}"

export PING_ARTIFACT_REPO_URL="${PING_ARTIFACT_REPO_URL:-https://ping-artifacts.s3-us-west-2.amazonaws.com}"

export PD_MONITOR_BUCKET_URL="${PD_MONITOR_BUCKET_URL:-ssm://pcpt/service/storage/pd-monitor/uri}"
export LOG_ARCHIVE_URL="${LOG_ARCHIVE_URL:-unused}"
export BACKUP_URL="${BACKUP_URL:-unused}"

export MYSQL_SERVICE_HOST="${MYSQL_SERVICE_HOST:-"pingcentraldb.${PRIMARY_TENANT_DOMAIN}"}"
export MYSQL_USER="${MYSQL_USER:-ssm://aws/reference/secretsmanager//pcpt/ping-central/dbserver#username}"
export MYSQL_PASSWORD="${MYSQL_PASSWORD:-ssm://aws/reference/secretsmanager//pcpt/ping-central/dbserver#password}"

export PING_IDENTITY_DEVOPS_USER="${PING_IDENTITY_DEVOPS_USER:-ssm://pcpt/devops-license/user}"
export PING_IDENTITY_DEVOPS_KEY="${PING_IDENTITY_DEVOPS_KEY:-ssm://pcpt/devops-license/key}"

PING_CLOUD_BASE_COMMIT_SHA=$(git rev-parse HEAD)
CURRENT_GIT_BRANCH=$(git rev-parse --abbrev-ref HEAD)
if test "${CURRENT_GIT_BRANCH}" = 'HEAD'; then
  CURRENT_GIT_BRANCH=$(git describe --tags --always)
fi

export CLUSTER_STATE_REPO_URL=${CLUSTER_STATE_REPO_URL:-https://github.com/pingidentity/ping-cloud-base}
CLUSTER_STATE_REPO_NAME="${CLUSTER_STATE_REPO_URL##*/}"

SERVER_PROFILE_URL_DERIVED="$(echo "${CLUSTER_STATE_REPO_URL}" | sed -e "s/${CLUSTER_STATE_REPO_NAME}/profile-repo/")"
export SERVER_PROFILE_URL="${SERVER_PROFILE_URL:-${SERVER_PROFILE_URL_DERIVED}}"

export K8S_GIT_URL="${K8S_GIT_URL:-https://github.com/pingidentity/ping-cloud-base.git}"
export K8S_GIT_BRANCH="${K8S_GIT_BRANCH:-${CURRENT_GIT_BRANCH}}"

export SSH_ID_PUB_FILE="${SSH_ID_PUB_FILE}"
export SSH_ID_KEY_FILE="${SSH_ID_KEY_FILE}"

export TARGET_DIR="${TARGET_DIR:-/tmp/sandbox}"

export ACCOUNT_BASE_PATH=${ACCOUNT_BASE_PATH:-ssm://pcpt/config/k8s-config/accounts/}
export ACCOUNT_PATH_PREFIX=${ACCOUNT_BASE_PATH#ssm:/}
export IRSA_BASE_PATH=${IRSA_BASE_PATH:-ssm://pcpt/irsa-role/}
export PGO_BUCKET_URI_SUFFIX=${PGO_BUCKET_URI_SUFFIX:-/pgo-bucket/uri}

# IRSA for ping product pods. The role name is predefined as a part of the interface contract.
export IRSA_PING_ANNOTATION_KEY_VALUE=${IRSA_PING_ANNOTATION_KEY_VALUE:-''}
export IRSA_PA_ANNOTATION_KEY_VALUE=${IRSA_PA_ANNOTATION_KEY_VALUE:-''}
export IRSA_PD_ANNOTATION_KEY_VALUE=${IRSA_PD_ANNOTATION_KEY_VALUE:-''}
export IRSA_PF_ANNOTATION_KEY_VALUE=${IRSA_PF_ANNOTATION_KEY_VALUE:-''}
export IRSA_ARGOCD_ANNOTATION_KEY_VALUE=${IRSA_ARGOCD_ANNOTATION_KEY_VALUE:-''}
export IRSA_CWAGENT_ANNOTATION_KEY_VALUE=${IRSA_CWAGENT_ANNOTATION_KEY_VALUE:-''}
export IRSA_INGRESS_ANNOTATION_KEY_VALUE=${IRSA_INGRESS_ANNOTATION_KEY_VALUE:-''}

export CLUSTER_ENDPOINT=${CLUSTER_ENDPOINT:-''}
export KARPENTER_INSTANCE_PROFILE=${KARPENTER_INSTANCE_PROFILE:-"KarpenterInstanceProfile"}

export KARPENTER_ROLE_ANNOTATION_KEY_VALUE=${KARPENTER_ROLE_ANNOTATION_KEY_VALUE:-''}

export NLB_NGX_PUBLIC_ANNOTATION_KEY_VALUE=${NLB_NGX_PUBLIC_ANNOTATION_KEY_VALUE:-''}

### Variable used by argocd-image-updater to scan container image tags matching the prefix.
export IMAGE_TAG_PREFIX="DISABLE"

### FEATURE FLAG DEFAULTS ###
export PF_PROVISIONING_ENABLED="${PF_PROVISIONING_ENABLED:-false}"
export RADIUS_PROXY_ENABLED="${RADIUS_PROXY_ENABLED:-false}"
export ARGOCD_BOOTSTRAP_ENABLED="${ARGOCD_BOOTSTRAP_ENABLED:-true}"
export EXTERNAL_INGRESS_ENABLED="${EXTERNAL_INGRESS_ENABLED:-""}"

### Default environment variables ###
export ECR_REGISTRY_NAME='public.ecr.aws/r2h3l6e4'
export PING_CLOUD_NAMESPACE='ping-cloud'
export MYSQL_DATABASE="${MYSQL_DATABASE:-pingcentral}"
export ARGOCD_CDE_ROLE_SSM_TEMPLATE="${ARGOCD_CDE_ROLE_SSM_TEMPLATE:-"${ACCOUNT_PATH_PREFIX}{env}/argo/role/arn"}"
export ARGOCD_CDE_URL_SSM_TEMPLATE="${ARGOCD_CDE_URL_SSM_TEMPLATE:-"${ACCOUNT_PATH_PREFIX}{env}/cluster/private-link/cname"}"

DEFAULT_IMAGE_LIST="apps=${ECR_REGISTRY_NAME}/pingcloud-apps/pingfederate,apps=${ECR_REGISTRY_NAME}/pingcloud-apps/pingaccess,apps=${ECR_REGISTRY_NAME}/pingcloud-apps/pingaccess-was"
export IMAGE_LIST="DISABLE"

ALL_ENVIRONMENTS='dev test stage prod customer-hub'
SUPPORTED_ENVIRONMENT_TYPES="${SUPPORTED_ENVIRONMENT_TYPES:-${ALL_ENVIRONMENTS}}"

if [[ "${UPGRADE}" == "true" ]]; then
  # We want to keep the original value of ARGOCD_ENVIRONMENTS from CSR generation, if this is an upgrade
  export ARGOCD_ENVIRONMENTS="${ARGOCD_ENVIRONMENTS}"
else
  # As of this change (PDO-5017), ENVIRONMENTS is now only used to set ARGOCD_ENVIRONMENTS
  export ARGOCD_ENVIRONMENTS="${ENVIRONMENTS:-${SUPPORTED_ENVIRONMENT_TYPES}}"
fi

# Set Slack-related environment variables and override it's values depending on IS_GA value.
get_is_ga_variable '/pcpt/stage/is-ga'

# The Kustomize path to determine configuration to use, either ga or non-ga.
if [[ "${IS_GA}" == "true" ]]; then
  export ACCOUNT_TYPE='ga'
else
  export ACCOUNT_TYPE='non-ga'
fi

export NON_GA_SLACK_CHANNEL="${NON_GA_SLACK_CHANNEL:-nowhere}"
# If IS_GA=true, use default Slack channel; if IS_GA=false, use NON_GA_SLACK_CHANNEL value as Slack channel.
if "${IS_GA}"; then
  export SLACK_CHANNEL="${SLACK_CHANNEL:-p1as-application-oncall}"
  export PROM_SLACK_CHANNEL="${PROM_SLACK_CHANNEL:-p1as-application-oncall}"
else
  export SLACK_CHANNEL="${SLACK_CHANNEL:-${NON_GA_SLACK_CHANNEL}}"
  export PROM_SLACK_CHANNEL="${PROM_SLACK_CHANNEL:-${NON_GA_SLACK_CHANNEL}}"
fi

NEW_RELIC_LICENSE_KEY="${NEW_RELIC_LICENSE_KEY:-ssm://pcpt/sre/new-relic/java-agent-license-key}"
if [[ ${NEW_RELIC_LICENSE_KEY} == "ssm://"* ]]; then
  if ! ssm_value=$(get_ssm_value "${NEW_RELIC_LICENSE_KEY#ssm:/}"); then
    echo "Warn: ${ssm_value}"
    echo "Setting NEW_RELIC_LICENSE_KEY to unused"
    NEW_RELIC_LICENSE_KEY="unused"
  else
    NEW_RELIC_LICENSE_KEY="${ssm_value}"
  fi
fi

export NEW_RELIC_LICENSE_KEY_BASE64=$(base64_no_newlines "${NEW_RELIC_LICENSE_KEY}")

# Adding an ArgoCD notification slack token
ARGOCD_SLACK_TOKEN_SSM_PATH="${ARGOCD_SLACK_TOKEN_SSM_PATH:-ssm://pcpt/argocd/notification/slack/access_token}"
if ! ssm_value=$(get_ssm_value "${ARGOCD_SLACK_TOKEN_SSM_PATH#ssm:/}"); then
  echo "Warn: ${ssm_value}"
  echo "ARGOCD_SLACK_TOKEN is unset, slack notification and argo-events will not work"
  echo "Using default invalid token"
  ARGOCD_SLACK_TOKEN="using_default_invalid_token"
else
  ARGOCD_SLACK_TOKEN="${ssm_value}"
fi

export ARGOCD_SLACK_TOKEN_BASE64=$(base64_no_newlines "${ARGOCD_SLACK_TOKEN}")

set_ssh_key_pair

# Get the known hosts contents for the cluster state repo host to pass it into the CD container.
parse_url "${CLUSTER_STATE_REPO_URL}"
echo "Obtaining known_hosts contents for cluster state repo host: ${URL_HOST}"

if test ! "${KNOWN_HOSTS_CLUSTER_STATE_REPO}"; then
  # For GitHub, use the 'ecdsa' SSH host key type. The CD tool doesn't work with RSA keys. For all others, use 'rsa'.
  # FIXME: make SSH_HOST_KEY_TYPE overridable in the future. Ref: "man ssh-keyscan".
  if echo "${URL_HOST}" | grep -q 'github.com'; then
    SSH_HOST_KEY_TYPE='ecdsa'
  else
    SSH_HOST_KEY_TYPE='rsa'
  fi
  KNOWN_HOSTS_CLUSTER_STATE_REPO="$(ssh-keyscan -t "${SSH_HOST_KEY_TYPE}" -H "${URL_HOST}" 2>/dev/null)"
fi
export KNOWN_HOSTS_CLUSTER_STATE_REPO

get_is_myping_variable "${CUSTOMER_SSO_SSM_PATH_PREFIX}/is-myping"

# Set some product specific variables
export USER_BASE_DN="${USER_BASE_DN:-dc=example,dc=com}"
export USER_BASE_DN_2="${USER_BASE_DN_2}"
export USER_BASE_DN_3="${USER_BASE_DN_3}"
export USER_BASE_DN_4="${USER_BASE_DN_4}"
export USER_BASE_DN_5="${USER_BASE_DN_5}"

export PA_WAS_GCOPTION='-XX:+UseParallelGC'
export PA_MIN_HEAP=1024m
export PA_MAX_HEAP=1024m
export PA_MIN_YGEN=512m
export PA_MAX_YGEN=512m
export PA_GCOPTION='-XX:+UseParallelGC'

export APP_RESYNC_SECONDS="${APP_RESYNC_SECONDS:-60}"

########################################################################################################################
# Print out the final value being used for each variable.
########################################################################################################################
echo "Using TENANT_NAME: ${TENANT_NAME}"
echo "Using SIZE: ${SIZE}"

echo "Using SUPPORTED_ENVIRONMENT_TYPES: ${SUPPORTED_ENVIRONMENT_TYPES}"
echo "Using IS_MULTI_CLUSTER: ${IS_MULTI_CLUSTER}"
echo "Using PLATFORM_EVENT_QUEUE_NAME: ${PLATFORM_EVENT_QUEUE_NAME}"
echo "Using CUSTOMER_SSM_PATH_PREFIX: ${CUSTOMER_SSM_PATH_PREFIX}"
echo "Using CUSTOMER_SSO_SSM_PATH_PREFIX: ${CUSTOMER_SSO_SSM_PATH_PREFIX}"
echo "Using SERVICE_SSM_PATH_PREFIX: ${SERVICE_SSM_PATH_PREFIX}"
echo "Using REGION: ${REGION}"
echo "Using REGION_NICK_NAME: ${REGION_NICK_NAME}"
echo "Using PRIMARY_REGION: ${PRIMARY_REGION}"
echo "Using TENANT_DOMAIN: ${TENANT_DOMAIN}"
echo "Using GLOBAL_TENANT_DOMAIN: ${GLOBAL_TENANT_DOMAIN}"
echo "Using PRIMARY_TENANT_DOMAIN: ${PRIMARY_TENANT_DOMAIN}"
echo "Using SECONDARY_TENANT_DOMAINS: ${SECONDARY_TENANT_DOMAINS}"
echo "Using PING_CLOUD_NAMESPACE: ${PING_CLOUD_NAMESPACE}"

echo "Using CLUSTER_STATE_REPO_URL: ${CLUSTER_STATE_REPO_URL}"
echo "Using SERVER_PROFILE_URL: ${SERVER_PROFILE_URL}"
echo "Using CLUSTER_STATE_REPO_PATH: ${REGION_NICK_NAME}"

echo "Using ARTIFACT_REPO_URL: ${ARTIFACT_REPO_URL}"
echo "Using PING_ARTIFACT_REPO_URL: ${PING_ARTIFACT_REPO_URL}"
echo "Using PD_MONITOR_BUCKET_URL: ${PD_MONITOR_BUCKET_URL}"
echo "Using LOG_ARCHIVE_URL: ${LOG_ARCHIVE_URL}"
echo "Using BACKUP_URL: ${BACKUP_URL}"

echo "Using MYSQL_SERVICE_HOST: ${MYSQL_SERVICE_HOST}"
echo "Using MYSQL_USER: ${MYSQL_USER}"
echo "Using MYSQL_DATABASE: ${MYSQL_DATABASE}"

echo "Using PING_IDENTITY_DEVOPS_USER: ${PING_IDENTITY_DEVOPS_USER}"

echo "Using K8S_GIT_URL: ${K8S_GIT_URL}"
echo "Using K8S_GIT_BRANCH: ${K8S_GIT_BRANCH}"

echo "Using SSH_ID_PUB_FILE: ${SSH_ID_PUB_FILE:-'<auto-generated>'}"
echo "Using SSH_ID_KEY_FILE: ${SSH_ID_KEY_FILE:-'<auto-generated>'}"

echo "Using PF_PROVISIONING_ENABLED: ${PF_PROVISIONING_ENABLED}"
echo "Using RADIUS_PROXY_ENABLED: ${RADIUS_PROXY_ENABLED}"
echo "Using ARGOCD_BOOTSTRAP_ENABLED: ${ARGOCD_BOOTSTRAP_ENABLED}"
echo "Using EXTERNAL_INGRESS_ENABLED: ${EXTERNAL_INGRESS_ENABLED}"
echo "Using TARGET_DIR: ${TARGET_DIR}"
echo "Using IS_BELUGA_ENV: ${IS_BELUGA_ENV}"

echo "Using ACCOUNT_BASE_PATH: ${ACCOUNT_BASE_PATH}"
echo "Using PGO_BUCKET_URI_SUFFIX: ${PGO_BUCKET_URI_SUFFIX}"
echo "Using ARGOCD_CDE_ROLE_SSM_TEMPLATE: ${ARGOCD_CDE_ROLE_SSM_TEMPLATE}"
echo "Using ARGOCD_CDE_URL_SSM_TEMPLATE: ${ARGOCD_CDE_URL_SSM_TEMPLATE}"
echo "Using ARGOCD_ENVIRONMENTS: ${ARGOCD_ENVIRONMENTS}"

echo "Using IRSA_PING_ANNOTATION_KEY_VALUE: ${IRSA_PING_ANNOTATION_KEY_VALUE}"
echo "Using IRSA_PA_ANNOTATION_KEY_VALUE: ${IRSA_PA_ANNOTATION_KEY_VALUE}"
echo "Using IRSA_PD_ANNOTATION_KEY_VALUE: ${IRSA_PD_ANNOTATION_KEY_VALUE}"
echo "Using IRSA_PF_ANNOTATION_KEY_VALUE: ${IRSA_PF_ANNOTATION_KEY_VALUE}"
echo "Using IRSA_ARGOCD_ANNOTATION_KEY_VALUE: ${IRSA_ARGOCD_ANNOTATION_KEY_VALUE}"
echo "Using IRSA_CWAGENT_ANNOTATION_KEY_VALUE: ${IRSA_CWAGENT_ANNOTATION_KEY_VALUE}"
echo "Using IRSA_INGRESS_ANNOTATION_KEY_VALUE: ${IRSA_INGRESS_ANNOTATION_KEY_VALUE}"

echo "Using CLUSTER_ENDPOINT: ${CLUSTER_ENDPOINT}"
echo "Using KARPENTER_INSTANCE_PROFILE: ${KARPENTER_INSTANCE_PROFILE}"

echo "Using KARPENTER_ROLE_ANNOTATION_KEY_VALUE: ${KARPENTER_ROLE_ANNOTATION_KEY_VALUE}"

echo "Using NLB_NGX_PUBLIC_ANNOTATION_KEY_VALUE: ${NLB_NGX_PUBLIC_ANNOTATION_KEY_VALUE}"

echo "Using SLACK_CHANNEL: ${SLACK_CHANNEL}"
echo "Using PROM_SLACK_CHANNEL: ${PROM_SLACK_CHANNEL}"

echo "Using APP_RESYNC_SECONDS: ${APP_RESYNC_SECONDS}"

echo "Using USER_BASE_DN: ${USER_BASE_DN}"

echo "Using IMAGE_LIST: ${IMAGE_LIST}"
echo "Using IMAGE_TAG_PREFIX: ${IMAGE_TAG_PREFIX}"

echo "Using DASHBOARD_REPO_URL: ${DASHBOARD_REPO_URL}"

echo ---


########################################################################################################################
# Set variables for massaging files into correct structure for CSR
########################################################################################################################

TEMPLATES_HOME="${SCRIPT_HOME}/templates"
COMMON_TEMPLATES_DIR="${TEMPLATES_HOME}/common"
CHUB_TEMPLATES_DIR="${TEMPLATES_HOME}/customer-hub"
CDE_TEMPLATES_DIR="${TEMPLATES_HOME}/cde"

# Delete existing target directory and re-create it
rm -rf "${TARGET_DIR}"
mkdir -p "${TARGET_DIR}"

# Next build up the directory structure of the cluster-state repo
BOOTSTRAP_SHORT_DIR='fluxcd'
BOOTSTRAP_DIR="${TARGET_DIR}/${BOOTSTRAP_SHORT_DIR}"

CLUSTER_STATE_REPO_DIR="${TARGET_DIR}/cluster-state"
PROFILE_REPO_DIR="${TARGET_DIR}/profile-repo"
PROFILES_DIR="${PROFILE_REPO_DIR}/profiles"

CUSTOMER_HUB='customer-hub'
PING_CENTRAL='pingcentral'
PING_ACCESS='pingaccess'

mkdir -p "${BOOTSTRAP_DIR}"
mkdir -p "${CLUSTER_STATE_REPO_DIR}"
mkdir -p "${PROFILE_REPO_DIR}"

cp ./upgrade-cluster-state-wrapper.sh "${CLUSTER_STATE_REPO_DIR}"
cp ./csr-validation.sh "${CLUSTER_STATE_REPO_DIR}"
cp ./seal-secret-values.py "${CLUSTER_STATE_REPO_DIR}"
cp ./upgrade-profile-wrapper.sh "${PROFILE_REPO_DIR}"

cp ../.gitignore "${CLUSTER_STATE_REPO_DIR}"
cp ../.gitignore "${PROFILE_REPO_DIR}"

echo "${PING_CLOUD_BASE_COMMIT_SHA}" > "${TARGET_DIR}/pcb-commit-sha.txt"

# The SUPPORTED_ENVIRONMENT_TYPES variable can either be the CDE names (e.g. dev, test, stage, prod) or the CHUB name "customer-hub",
# or the corresponding branch names (e.g. v1.8.0-dev, v1.8.0-test, v1.8.0-stage, v1.8.0-master, v1.8.0-customer-hub).
# We must handle both cases. Note that the 'prod' environment will have a branch name suffix of 'master'.
for ENV_OR_BRANCH in ${SUPPORTED_ENVIRONMENT_TYPES}; do
# Run in a sub-shell so the current shell is not polluted with environment variables.
(
  ######################################################################################################################
  # Set the values for each environment specific variable.
  ######################################################################################################################

  if echo "${ENV_OR_BRANCH}" | grep -q "${CUSTOMER_HUB}"; then
    GIT_BRANCH="${CUSTOMER_HUB}"

    ENV_OR_BRANCH_SUFFIX="${CUSTOMER_HUB}"
    ENV="${CUSTOMER_HUB}"

    export CLUSTER_STATE_REPO_BRANCH="${CUSTOMER_HUB}"
  else
    test "${ENV_OR_BRANCH}" = 'prod' &&
        GIT_BRANCH='master' ||
        GIT_BRANCH="${ENV_OR_BRANCH}"

    ENV_OR_BRANCH_SUFFIX="${ENV_OR_BRANCH##*-}"
    test "${ENV_OR_BRANCH_SUFFIX}" = 'master' &&
        ENV='prod' ||
        ENV="${ENV_OR_BRANCH_SUFFIX}"

    # Set the cluster state repo branch to the default CDE branch, i.e. dev, test, stage or master.
    export CLUSTER_STATE_REPO_BRANCH="${GIT_BRANCH##*-}"
  fi

  # Export all the environment variables required for envsubst
  export ENV="${ENV}"
  export ENVIRONMENT_TYPE="\${ENV}"

  echo "-----> Starting to create environment '${ENV}'"

  # The base URL for kustomization files and environment will be different for each CDE.
  # On migrated customers, we must preserve the size of the customers.
  case "${ENV}" in
    dev | test)
      export KUSTOMIZE_BASE="${KUSTOMIZE_BASE:-test}"
      ;;
    stage | prod | customer-hub)
      export KUSTOMIZE_BASE="${KUSTOMIZE_BASE:-prod/${SIZE}}"
      ;;
  esac

  # Update the Let's encrypt server to use staging/production based on GA/MyPing customers or the environment type.
  PROD_LETS_ENCRYPT_SERVER='https://acme-v02.api.letsencrypt.org/directory'
  STAGE_LETS_ENCRYPT_SERVER='https://acme-staging-v02.api.letsencrypt.org/directory'

  if test ! "${LETS_ENCRYPT_SERVER}"; then
    if "${IS_GA}"; then
      LETS_ENCRYPT_SERVER="${PROD_LETS_ENCRYPT_SERVER}"
    else
      case "${ENV}" in
        dev | test | stage)
          LETS_ENCRYPT_SERVER="${STAGE_LETS_ENCRYPT_SERVER}"
          ;;
        prod | customer-hub)
          LETS_ENCRYPT_SERVER="${PROD_LETS_ENCRYPT_SERVER}"
          ;;
      esac
    fi
  fi
  export LETS_ENCRYPT_SERVER="${LETS_ENCRYPT_SERVER}"

  # Set PF variables based on ENV
  if echo "${LETS_ENCRYPT_SERVER}" | grep -q 'staging'; then
    export PF_PD_BIND_PORT=1389
    export PF_PD_BIND_PROTOCOL=ldap
    export PF_PD_BIND_USESSL=false
  else
    export PF_PD_BIND_PORT=1636
    export PF_PD_BIND_PROTOCOL=ldaps
    export PF_PD_BIND_USESSL=true
  fi

  # Update the product specific variables based on environment.
  case "${ENV}" in
    dev | test)
      # Set PF variables
      export PF_MIN_HEAP=1536m
      export PF_MAX_HEAP=1536m
      export PF_MIN_YGEN=768m
      export PF_MAX_YGEN=768m

      # Set PA variables
      export PA_WAS_MIN_HEAP=1024m
      export PA_WAS_MAX_HEAP=1024m
      export PA_WAS_MIN_YGEN=512m
      export PA_WAS_MAX_YGEN=512m
      ;;
    stage | prod | customer-hub)
      # Set PF variables
      export PF_MIN_HEAP=3072m
      export PF_MAX_HEAP=3072m
      export PF_MIN_YGEN=1536m
      export PF_MAX_YGEN=1536m

      # Set PA variables
      export PA_WAS_MIN_HEAP=2048m
      export PA_WAS_MAX_HEAP=2048m
      export PA_WAS_MIN_YGEN=1024m
      export PA_WAS_MAX_YGEN=1024m
      ;;
  esac

  "${IS_BELUGA_ENV}" &&
      export CLUSTER_NAME="${TENANT_NAME}" ||
      export CLUSTER_NAME="${ENV}"

  CLUSTER_NAME_LC="$(echo "${CLUSTER_NAME}" | tr '[:upper:]' '[:lower:]')"
  export CLUSTER_NAME_LC="${CLUSTER_NAME_LC}"

  add_derived_variables

  # TODO: With https://pingidentity.atlassian.net/browse/PP-5719 we should see all of the IRSA roles represented like
  # ArgoCD, then we can change this IRSA SSM fetch code to be consistent
  # shellcheck disable=SC2016
  IRSA_TEMPLATE='eks.amazonaws.com/role-arn: arn:aws:iam::${ssm_value}:role/pcpt/irsa-roles'
  set_var "IRSA_PING_ANNOTATION_KEY_VALUE" "" "${ACCOUNT_BASE_PATH}" "${ENV}" "${IRSA_TEMPLATE}/irsa-ping"
  set_var "IRSA_PA_ANNOTATION_KEY_VALUE" "" "${ACCOUNT_BASE_PATH}" "${ENV}" "${IRSA_TEMPLATE}/irsa-pingaccess"
  set_var "IRSA_PD_ANNOTATION_KEY_VALUE" "" "${ACCOUNT_BASE_PATH}" "${ENV}" "${IRSA_TEMPLATE}/irsa-pingdirectory"
  set_var "IRSA_PF_ANNOTATION_KEY_VALUE" "" "${ACCOUNT_BASE_PATH}" "${ENV}" "${IRSA_TEMPLATE}/irsa-pingfederate"
  set_var "IRSA_CWAGENT_ANNOTATION_KEY_VALUE" "" "${ACCOUNT_BASE_PATH}" "${ENV}" "${IRSA_TEMPLATE}/irsa-cloudwatch-agent"

  # shellcheck disable=SC2016
  IRSA_TEMPLATE='eks.amazonaws.com/role-arn: ${ssm_value}'
  set_var "IRSA_ARGOCD_ANNOTATION_KEY_VALUE" "" "${IRSA_BASE_PATH}" "irsa-argocd/arn" "${IRSA_TEMPLATE}"

  set_var "IRSA_INGRESS_ANNOTATION_KEY_VALUE" "" "${ACCOUNT_BASE_PATH}" "${ENV}/irsa-role/ingress-controller/arn" "${IRSA_TEMPLATE}"

  # shellcheck disable=SC2016
  KARPENTER_ROLE_TEMPLATE='eks.amazonaws.com/role-arn: arn:aws:iam::${ssm_value}:role'
  set_var "KARPENTER_ROLE_ANNOTATION_KEY_VALUE" "" "${ACCOUNT_BASE_PATH}" "${ENV}" \
          "${KARPENTER_ROLE_TEMPLATE}/KarpenterControllerRole"

  set_var "CLUSTER_ENDPOINT" "" "${ACCOUNT_BASE_PATH}${ENV}" "/cluster_endpoint"

  # shellcheck disable=SC2016
  NLB_TEMPLATE='service.beta.kubernetes.io/aws-load-balancer-eip-allocations: ${ssm_value}'
  set_var "NLB_NGX_PUBLIC_ANNOTATION_KEY_VALUE" "" "${NLB_EIP_PATH_PREFIX:-unused}" "/${ENV}/nginx-public" \
          "${NLB_TEMPLATE}"

  set_var "PGO_BACKUP_BUCKET_NAME" "not_set" "${ACCOUNT_BASE_PATH}${ENV}" "${PGO_BUCKET_URI_SUFFIX}"
  # Remove s3:// prefix if present
  export PGO_BACKUP_BUCKET_NAME=${PGO_BACKUP_BUCKET_NAME#s3://}

  ######################################################################################################################
  # Print out the final value being used for each environment specific variable.
  ######################################################################################################################
  echo ---
  echo "For environment ${ENV}:"
  echo "Using CLUSTER_STATE_REPO_BRANCH: ${CLUSTER_STATE_REPO_BRANCH}"
  echo "Using ENVIRONMENT_TYPE: ${ENVIRONMENT_TYPE}"
  echo "Using KUSTOMIZE_BASE: ${KUSTOMIZE_BASE}"
  echo "Using ACCOUNT_TYPE: ${ACCOUNT_TYPE}"
  echo "Using LETS_ENCRYPT_SERVER: ${LETS_ENCRYPT_SERVER}"
  echo "Using CLUSTER_NAME: ${CLUSTER_NAME}"
  echo "Using DNS_ZONE: ${DNS_ZONE}"
  echo "Using PRIMARY_DNS_ZONE: ${PRIMARY_DNS_ZONE}"
  echo "Using PGO_BACKUP_BUCKET_NAME: ${PGO_BACKUP_BUCKET_NAME}"
  echo "Using IRSA_PING_ANNOTATION_KEY_VALUE: ${IRSA_PING_ANNOTATION_KEY_VALUE}"
  echo "Using KARPENTER_ROLE_ANNOTATION_KEY_VALUE: ${KARPENTER_ROLE_ANNOTATION_KEY_VALUE}"
  echo "Using IRSA_INGRESS_ANNOTATION_KEY_VALUE: ${IRSA_INGRESS_ANNOTATION_KEY_VALUE}"
  echo "Using NLB_NGX_PUBLIC_ANNOTATION_KEY_VALUE: ${NLB_NGX_PUBLIC_ANNOTATION_KEY_VALUE}"
  echo "Using CLUSTER_ENDPOINT: ${CLUSTER_ENDPOINT}"

  ######################################################################################################################
  # Massage files into correct structure for push-cluster-state script
  ######################################################################################################################

  ####### Bootstrap logic ##############################################################################################
  echo "Generating bootstrap yaml for ${ENV}"
  ENV_BOOTSTRAP_DIR="${BOOTSTRAP_DIR}/${ENV_OR_BRANCH}"
  mkdir -p "${ENV_BOOTSTRAP_DIR}"
  cp "${TEMPLATES_HOME}/${BOOTSTRAP_SHORT_DIR}"/common/* "${ENV_BOOTSTRAP_DIR}"
  if [[ "${ENV}" == "${CUSTOMER_HUB}" || "${IS_BELUGA_ENV}" == "true" ]]; then
    cp "${TEMPLATES_HOME}/${BOOTSTRAP_SHORT_DIR}"/customer-hub/* "${ENV_BOOTSTRAP_DIR}"
    # Copy all files from customer-hub code-gen, except kustomization.yaml to re-use the yaml there and prevent duplication
    find "${CHUB_TEMPLATES_DIR}/base/cluster-tools/git-ops" -type f ! -name kustomization.yaml | xargs -I {} cp {} "${ENV_BOOTSTRAP_DIR}"
    # Append the regional env-vars to the common env_vars to make sure all env vars are available for initial bootstrap
    cat "${CHUB_TEMPLATES_DIR}/region/git-ops/env_vars" >> "${ENV_BOOTSTRAP_DIR}/env_vars"
  else
    cp "${TEMPLATES_HOME}/${BOOTSTRAP_SHORT_DIR}"/cde/* "${ENV_BOOTSTRAP_DIR}"
  fi
  substitute_vars "${ENV_BOOTSTRAP_DIR}" "${BOOTSTRAP_VARS}"
  ####### END Bootstrap logic ##########################################################################################

  # Copy the shared cluster tools and Ping yaml templates into their target directories
  echo "Generating tools and ping yaml for ${ENV}"

  ENV_DIR="${CLUSTER_STATE_REPO_DIR}/${ENV_OR_BRANCH}"
  mkdir -p "${ENV_DIR}"

  K8S_CONFIGS_DIR="${ENV_DIR}/k8s-configs"
  mkdir -p "${K8S_CONFIGS_DIR}"

  cp ../k8s-configs/cluster-tools/base/git-ops/git-ops-command.sh "${K8S_CONFIGS_DIR}"

  # Copy the templates directory files (ex: seal.sh, region-promotion.txt) to the tmp dir
  find "${TEMPLATES_HOME}" -type f -maxdepth 1 | xargs -I {} cp {} "${K8S_CONFIGS_DIR}"

  # Copy the common templates first.
  cd "${COMMON_TEMPLATES_DIR}"
  rsync -rR * "${K8S_CONFIGS_DIR}"
  cd - >/dev/null 2>&1

  # Overlay the CHUB or CDE specific templates next.
  if test "${ENV}" = "${CUSTOMER_HUB}"; then
    cd "${CHUB_TEMPLATES_DIR}"
  else
    cd "${CDE_TEMPLATES_DIR}"
  fi

  rsync -rR * "${K8S_CONFIGS_DIR}"
  cd - >/dev/null 2>&1

  # Rename to the actual region nick name.
  mv "${K8S_CONFIGS_DIR}/region" "${K8S_CONFIGS_DIR}/${REGION_NICK_NAME}"

  # Massage files from new microservice architecture
  organize_code_for_csr

  PRIMARY_PING_KUST_FILE="${K8S_CONFIGS_DIR}/${REGION_NICK_NAME}/kustomization.yaml"

  # Copy around files for Developer CDE before substituting vars
  if "${IS_BELUGA_ENV}"; then
    echo "IS_BELUGA_ENV detected, making developer changes to deployment"
    # Add IS_BELUGA_ENV to the base env_vars
    BASE_ENV_VARS="${K8S_CONFIGS_DIR}/base/env_vars"
    echo >> "${BASE_ENV_VARS}"
    echo "IS_BELUGA_ENV=true" >> "${BASE_ENV_VARS}"

    # Add IS_BELUGA_ENV to the base values.yaml
    substitute_vars "${ENV_DIR}/values-files" '${IS_BELUGA_ENV}'

    # Update patches related to Beluga developer CDEs

    # Do not disable CW and NR if in CI/CD
    if test "${CI_SERVER}" != "yes"; then
      sed -i.bak 's/^[[:space:]]*# \(.*remove-from-developer-cde-patch.yaml\)$/  \1/g' "${PRIMARY_PING_KUST_FILE}"
    fi
    rm -f "${PRIMARY_PING_KUST_FILE}.bak"

    # Add ArgoCD to Beluga Environments since it normally runs only in customer-hub
    echo "This is a Beluga Development Environment, copying ArgoCD into the CSR"
    cp -R "${CHUB_TEMPLATES_DIR}/base/cluster-tools/git-ops" "${K8S_CONFIGS_DIR}/base/cluster-tools/"
    cp "${ENV_BOOTSTRAP_DIR}/env_vars" "${K8S_CONFIGS_DIR}/base/cluster-tools/git-ops/"
    # Append the secrets from customer-hub to the CDE secrets, except PingCentral since that doesn't exist in the CDE
    printf "\n# %%%% NOTE: Below secrets are for the Developer CDE only (when IS_BELUGA_ENV is 'true') to make sure Argo works properly %%%%#\n" >> "${K8S_CONFIGS_DIR}/base/secrets.yaml"
    yq 'del(select(.metadata.name | contains("pingcentral")))' "${CHUB_TEMPLATES_DIR}/base/secrets.yaml" >> "${K8S_CONFIGS_DIR}/base/secrets.yaml"
    printf "\n# %%%% END automatically appended secrets from generate-cluster-state.sh\n" >> "${K8S_CONFIGS_DIR}/base/secrets.yaml"
  fi

  echo "Substituting env vars, this may take some time..."
  substitute_vars "${ENV_DIR}" "${REPO_VARS}" secrets.yaml env_vars

  # Regional enablement - add admins, backups, etc. to primary and adding pingaccess-was and pingcentral to primary.
  if test "${TENANT_DOMAIN}" = "${PRIMARY_TENANT_DOMAIN}"; then
    sed -i.bak 's/^\(.*remove-from-secondary-patch.yaml\)$/# \1/g' "${PRIMARY_PING_KUST_FILE}"
    rm -f "${PRIMARY_PING_KUST_FILE}.bak"
  fi

  echo "Copying server profiles for environment ${ENV}"
  ENV_PROFILES_DIR="${PROFILES_DIR}/${ENV_OR_BRANCH}"
  mkdir -p "${ENV_PROFILES_DIR}"

  cp -pr profiles/. "${ENV_PROFILES_DIR}"

  if test "${ENV}" = "${CUSTOMER_HUB}"; then
    echo "CHUB deploy identified, retaining only PingCentral and PingAccess profiles"
    # Retain only the pingcentral & pingaccess profiles
    find "${ENV_PROFILES_DIR}" -type d -mindepth 1 -maxdepth 1 -not -name "${PING_CENTRAL}" -not -name "${PING_ACCESS}" -exec rm -rf {} +
  elif test "${ENV}" = "dev" && "${IS_BELUGA_ENV}" &&  test "${CI_SERVER}" = "yes"; then
    echo "Running a dev cluster in CI/CD pipeline, not removing PingCentral profiles"
  else
    # Remove the pingcentral profiles
    echo "Not CI/CD or CHUB deploy, removing PingCentral profiles"
    rm -rf "${ENV_PROFILES_DIR}/${PING_CENTRAL}"
  fi

  echo "=====> Done creating environment '${ENV}'"
)
done

cp -p push-cluster-state.sh "${TARGET_DIR}"

# Go back to previous working directory, if different
popd >/dev/null 2>&1

if ! "${QUIET}"; then
  echo
  echo '------------------------'
  echo '|  Next steps to take  |'
  echo '------------------------'
  echo "1) Run ${TARGET_DIR}/push-cluster-state.sh to push the generated code into the tenant cluster-state repo:"
  echo "${CLUSTER_STATE_REPO_URL}"
  echo
  echo "2) Add the following identity as the deploy key on the cluster-state (rw), if not already added:"
  echo "${SSH_ID_PUB}"
  echo
  echo "3) Deploy bootstrap files onto each CDE by navigating to ${BOOTSTRAP_DIR} and running:"
  echo 'kustomize build | kubectl apply -f -'
fi
